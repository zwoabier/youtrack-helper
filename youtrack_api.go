package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype Ticket struct {\n\tID       string   `json:\"id\"`       // idReadable (AGV-10)\n\tSummary  string   `json:\"summary\"`\n\tType     string   `json:\"type\"`     // Parsed from customFields\n\tPriority string   `json:\"priority\"` // Parsed from customFields\n\tSprints  []string `json:\"sprints\"`  // Parsed from customFields\n\tURL      string   `json:\"url\"`      // Computed or fetched\n}\n\ntype YouTrackAPI struct {\n\tcm             *ConfigManager\n\tcachedTickets []Ticket\n\thttp           *http.Client\n}\n\nfunc NewYouTrackAPI(cm *ConfigManager) *YouTrackAPI {\n\treturn &YouTrackAPI{\n\t\tcm:             cm,\n\t\tcachedTickets: []Ticket{},\n\t\thttp:           &http.Client{},\n\t}\n}\n\n// SyncTickets fetches tickets from YouTrack API and updates cache\nfunc (yt *YouTrackAPI) SyncTickets(ctx context.Context) error {\n\tcfg := yt.cm.GetConfig()\n\ttoken := yt.cm.GetToken()\n\n\tif cfg.BaseURL == \"\" || token == \"\" {\n\t\treturn fmt.Errorf(\"YouTrack not configured\")\n\t}\n\n\t// Build YouTrack API query\n\tprojectQuery := strings.Join(cfg.Projects, \" or project: \")\n\tqueryStr := fmt.Sprintf(\"project: %s\", projectQuery)\n\n\t// Construct URL\n\tapiURL := fmt.Sprintf(\"%s/api/issues?query=%s&fields=idReadable,summary,customFields(name,value(name))&\\$top=5000\",\n\t\tcfg.BaseURL,\n\t\turl.QueryEscape(queryStr),\n\t)\n\n\t// Create request\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", apiURL, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set authorization header\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\t// Execute request\n\tresp, err := yt.http.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"YouTrack API error: %d - %s\", resp.StatusCode, string(body))\n\t}\n\n\tvar result struct {\n\t\tIssues []map[string]interface{} `json:\"issues\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn err\n\t}\n\n\t// Parse tickets\n\tyt.cachedTickets = []Ticket{}\n\tfor _, issue := range result.Issues {\n\t\tticket := yt.parseTicket(issue, cfg.BaseURL)\n\t\tyt.cachedTickets = append(yt.cachedTickets, ticket)\n\t}\n\n\treturn nil\n}\n\nfunc (yt *YouTrackAPI) parseTicket(issue map[string]interface{}, baseURL string) Ticket {\n\tticket := Ticket{}\n\n\t// Extract basic fields\n\tif id, ok := issue[\"idReadable\"].(string); ok {\n\t\tticket.ID = id\n\t}\n\tif summary, ok := issue[\"summary\"].(string); ok {\n\t\tticket.Summary = summary\n\t}\n\n\t// Construct URL\n\tticket.URL = fmt.Sprintf(\"%s/issues/%s\", baseURL, ticket.ID)\n\n\t// Parse custom fields\n\tif customFields, ok := issue[\"customFields\"].([]interface{}); ok {\n\t\tfor _, field := range customFields {\n\t\t\tif fieldMap, ok := field.(map[string]interface{}); ok {\n\t\t\t\tname, _ := fieldMap[\"name\"].(string)\n\t\t\t\t\n\t\t\t\tif value, ok := fieldMap[\"value\"]; ok {\n\t\t\t\t\tswitch name {\n\t\t\t\t\tcase \"Type\":\n\t\t\t\t\t\tif typeVal, ok := value.(map[string]interface{}); ok {\n\t\t\t\t\t\t\tif typeName, ok := typeVal[\"name\"].(string); ok {\n\t\t\t\t\t\t\t\tticket.Type = typeName\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase \"Priority\":\n\t\t\t\t\t\tif priVal, ok := value.(map[string]interface{}); ok {\n\t\t\t\t\t\t\tif priName, ok := priVal[\"name\"].(string); ok {\n\t\t\t\t\t\t\t\tticket.Priority = priName\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase \"Sprints\":\n\t\t\t\t\t\tif sprints, ok := value.([]interface{}); ok {\n\t\t\t\t\t\t\tfor _, sprint := range sprints {\n\t\t\t\t\t\t\t\tif sprintMap, ok := sprint.(map[string]interface{}); ok {\n\t\t\t\t\t\t\t\t\tif sprintName, ok := sprintMap[\"name\"].(string); ok {\n\t\t\t\t\t\t\t\t\t\tticket.Sprints = append(ticket.Sprints, sprintName)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ticket\n}\n\nfunc (yt *YouTrackAPI) GetCachedTickets() []Ticket {\n\treturn yt.cachedTickets\n}\n\n// ValidateConnection tests the API connection with provided credentials\nfunc (yt *YouTrackAPI) ValidateConnection(ctx context.Context, baseURL, token string) error {\n\tapiURL := fmt.Sprintf(\"%s/api/me\", baseURL)\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", apiURL, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := yt.http.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"invalid credentials or URL\")\n\t}\n\n\treturn nil\n}\n\n// GetProjects fetches available projects from YouTrack\nfunc (yt *YouTrackAPI) GetProjects(ctx context.Context, baseURL, token string) ([]string, error) {\n\tapiURL := fmt.Sprintf(\"%s/api/projects?fields=key\", baseURL)\n\n\treq, err := http.NewRequestWithContext(ctx, \"GET\", apiURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tresp, err := yt.http.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"failed to fetch projects: %d\", resp.StatusCode)\n\t}\n\n\tvar result struct {\n\t\tProjects []struct {\n\t\t\tKey string `json:\"key\"`\n\t\t} `json:\"projects\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tprojects := []string{}\n\tfor _, p := range result.Projects {\n\t\tprojects = append(projects, p.Key)\n\t}\n\n\treturn projects, nil\n}\n